name: Build Windows Executable

on:
  release:
    types: [published]
  workflow_dispatch: # 允许手动触发

permissions:
  contents: write
jobs:
  build-windows:
    runs-on: windows-latest # 使用最新的 Windows 环境
    strategy:
      matrix:
        rust: [stable]
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4 # 检出你的代码
    - name: Set up MSVC Developer Command Prompt
      uses: ilammy/msvc-dev-cmd@v1
    


    - name: Install OpenCV and LLVM
      run: choco install opencv --version=4.11.0 -y; choco install llvm -y

    - name: Discover and Set OpenCV Environment Variables
      id: set_opencv_vars
      run: |
          echo "OPENCV_INCLUDE_PATHS=C:\tools\opencv\build\include" >> $env:GITHUB_ENV

          $IncludePath = "C:\tools\opencv\build\include"
          echo "OPENCV_INCLUDE_PATHS=$IncludePath" >> $env:GITHUB_ENV
          Write-Output "OPENCV_INCLUDE_PATHS=$IncludePath"

          # Discover the lib path (robustly finds the vc* folder)
          $LibDir = (Get-ChildItem "C:\tools\opencv\build\x64" -Directory | Where-Object { $_.Name -like 'vc*' } | Select-Object -First 1)
          if (-not $LibDir) {
            Write-Error "Could not find the VC++ version-specific lib directory in $env:OpenCV_DIR\x64"
            exit 1
          }
          $LibPath = "$($LibDir.FullName)\lib"
          echo "OPENCV_LINK_PATHS=$LibPath" >> $env:GITHUB_ENV
          Write-Output "OPENCV_LINK_PATHS=$LibPath"
          
          # Discover all library names in that path
          $ReleaseLibNames = (Get-ChildItem $LibPath -Filter "*.lib" | Where-Object { $_.Name -notlike "*d.lib" }).Name -replace '\.lib$' -join ','
          if (-not $ReleaseLibNames) {
            Write-Error "Could not find any RELEASE .lib files (not ending with d.lib) in $LibPath"
            exit 1
          }
          echo "OPENCV_LINK_LIBS=$ReleaseLibNames" >> $env:GITHUB_ENV
          Write-Output "OPENCV_LINK_LIBS=$ReleaseLibNames"
         
      shell: pwsh
     
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: ${{ matrix.rust }}


    # 修改步骤: 使用 cargo bundle 而不是 cargo build
    - name: Bundle the release executable
      run: cargo build --release

    - name: Create Distribution Package
      id: create_package
      run: |
        $PKG_DIR = "release_package"
        New-Item -ItemType Directory -Force -Path $PKG_DIR

        Write-Output "Copying executable..."
        Copy-Item -Path "target/release/rust_polarimeter_gui.exe" -Destination $PKG_DIR

        # ======================================================================
        # vvvvvvvvvvvvvv     模糊查找 DLL 的核心改进     vvvvvvvvvvvvvvvv
        # ======================================================================
        Write-Output "Copying OpenCV DLLs using wildcards..."
        $OpenCVBinDir = (Get-ChildItem "C:\tools\opencv\build\x64" -Directory | Where-Object { $_.Name -like 'vc*' } | Select-Object -First 1).FullName + "\bin"

        $ReleaseDll = Get-ChildItem -Path $OpenCVBinDir -Filter "opencv_world*.dll" | Where-Object { $_.Name -notlike "*d.dll" } | Select-Object -First 1
        if ($ReleaseDll) {
            Write-Output "Found and copying Release DLL: $($ReleaseDll.Name)"
            Copy-Item -Path $ReleaseDll.FullName -Destination $PKG_DIR
        } else {
            # 如果找不到，构建应该失败，因为这是必需的依赖。
            Write-Error "FATAL: Could not find the release OpenCV world DLL."
            exit 1
        }
        # ======================================================================
        # ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        # ======================================================================

        Write-Output "Copying Microsoft VC++ Runtime DLLs..."
        Copy-Item -Path "$env:VCToolsRedistDir\x64\Microsoft.VC143.CRT\*.dll" -Destination $PKG_DIR

        Copy-Item -Path "exposure\调节曝光（Win）.exe" -Destination $PKG_DIR

        $ARTIFACT_NAME = "Win APP.zip"
        Compress-Archive -Path "$PKG_DIR\*" -DestinationPath $ARTIFACT_NAME
        
        echo "artifact_name=$ARTIFACT_NAME" >> $env:GITHUB_OUTPUT
      shell: pwsh

    - name: Upload Artifact (zip)
      uses: actions/upload-artifact@v4
      with:
        name: polarimeter-windows-package
        path: ${{ steps.create_package.outputs.artifact_name }}
  
  build-macos:
    runs-on: macos-latest # 使用最新的 macOS 环境

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Rust Toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        toolchain: stable

    - name: Install Dependencies (Homebrew & Cargo)
      run: |
        # GitHub Actions 的 macOS runner 自带 Homebrew
        echo "Installing OpenCV..."
        brew install opencv
        
        echo "Installing cargo-bundle..."
        cargo install cargo-bundle

    - name: Make Packaging Script Executable
      run: chmod +x package_macos.sh # 给予我们的打包脚本执行权限

    - name: Run Packaging Script
      # 这里直接执行我们之前编写好的脚本，完成所有核心打包工作
      run: ./package_macos.sh

    - name: Archive the Application
      id: archive_app
      run: |
        APP_NAME="Polarimeter"
        
        ARTIFACT_NAME="Mac APP.zip"
        
        echo "Archiving $APP_NAME.app to $ARTIFACT_NAME..."
        # cd target/release/bundle/osx/
        # zip -r "../../../${ARTIFACT_NAME}" "${APP_NAME}.app"
        # cd ../../../..
        mkdir package/
        cp -r "target/release/bundle/osx/${APP_NAME}.app" "package/"
        cp -r "exposure/调节曝光（Mac）.app" "package/"
        zip -r "${ARTIFACT_NAME}" "package"
        echo "artifact_name=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
      # shell: pwsh # 在 macOS runner 上也可以使用 PowerShell 来统一脚本语言

    - name: Upload Artifact (zip)
      uses: actions/upload-artifact@v4
      with:
        name: polarimeter-macos-package
        # 使用上一步生成的压缩包的完整路径
        path: ${{ steps.archive_app.outputs.artifact_name }}

  sync-to-gitee:
    name: Sync Release to Gitee
    runs-on: ubuntu-latest
    # ⭐ 关键：同时依赖 windows 和 macos 的构建 job
    needs: [build-windows, build-macos]
    steps:
      # 创建一个文件夹来存放所有要上传的文件
      - name: Create assets directory
        run: mkdir release-assets

      # 下载 Windows 构建产物到这个文件夹
      - name: Download Windows asset
        uses: actions/download-artifact@v4
        with:
          name: polarimeter-windows-package
          path: release-assets

      # 下载 macOS 构建产物到同一个文件夹
      - name: Download macOS asset
        uses: actions/download-artifact@v4
        with:
          name: polarimeter-macos-package
          path: release-assets
      
      # (可选) 打印文件夹内容，用于调试
      - name: List assets for debugging
        run: ls -R release-assets
        
      - name: Upload Windows Asset to GitHub Release
        uses: actions/upload-release-asset@v1
        with:
          # `upload_url` 是 GitHub 自动提供的，指向当前触发工作流的 Release
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release-assets/Win APP.zip
          asset_name: Win APP.zip
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload macOS Asset to GitHub Release
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: release-assets/Mac APP.zip
          asset_name: Mac APP.zip
          asset_content_type: application/zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      # 核心步骤：上传整个文件夹的内容到 Gitee
      - name: Create Release with Multiple Files
        uses: nicennnnnnnlee/action-gitee-release@master
        with:
          gitee_action: create_release
          gitee_owner: mengsb
          gitee_repo: polarimeter-download
          gitee_token: ${{ secrets.GITEE_PRIVATE_TOKEN }}
          gitee_tag_name: ${{ github.ref_name }}
          gitee_release_name: ${{ github.event.release.name }}
          gitee_target_commitish: master
          gitee_upload_retry_times: 3
          gitee_files: |
            release-assets/Mac APP.zip
            release-assets/Win APP.zip